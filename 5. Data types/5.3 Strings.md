# [Strings](https://javascript.info/string)

In JavaScript, the textual data is stored as strings. There is no separate type for a single character.

The internal format for strings is always [UTF-16](https://en.wikipedia.org/wiki/UTF-16), it is not tied to the page encoding.

# [Quotes](https://javascript.info/string#quotes)

Let‚Äôs recall the kinds of quotes.

Strings can be enclosed within either single quotes, double quotes or backticks:

	let single = 'single-quoted';
	let double = "double-quoted";

	let backticks = `backticks`;

Single and double quotes are essentially the same. Backticks, however, allow us to embed any expression into the string, including function calls:

	 function sum(a, b) {
	  return a + b;
	}

	alert(`1 + 2 = ${sum(1, 2)}.`); // 1 + 2 = 3.

Another advantage of using backticks is that they allow a string to span multiple lines:

	 let guestList = `Guests:
	 * John
	 * Pete
	 * Mary
	`;

	alert(guestList); // a list of guests, multiple lines

If we try to use single or double quotes in the same way, there will be an error:

	 let guestList = "Guests:  // Error: Unexpected token ILLEGAL
	  * John";

Single and double quotes come from ancient times of language creation when the need for multiline strings was not taken into account. Backticks appeared much later and thus are more versatile.

Backticks also allow us to specify a ‚Äútemplate function‚Äù before the first backtick. The syntax is: func`string`. The function func is called automatically, receives the string and embedded expressions and can process them. You can read more about it in the [docs](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#Tagged_template_literals). This is called**[‚Äútagged templates‚Äù](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#Tagged_template_literals)**. This feature makes it easier to wrap strings into custom templating or other functionality, but it is rarely used.

# [Special characters](https://javascript.info/string#special-characters)

## Character	Description
\b	Backspace
\f	Form feed
\n	New line
\r	Carriage return
\t	Tab
\uNNNN	A unicode symbol with the hex code NNNN, for instance \u00A9 ‚Äì is a unicode for the copyright symbol ¬©. It must be exactly 4 hex digits.
\u{NNNNNNNN}	Some rare characters are encoded with two unicode symbols, taking up to 4 bytes. This long unicode requires braces around it.

	alert( "\u00A9" ); // ¬©
	alert( "\u{1F60D}" ); // üòç, a smiling face symbol (another long unicode)

`All special characters start with a backslash character \. It is also called an ‚Äúescape character‚Äù.`

We would also use it if we want to insert a quote into the string.

For instance:

    alert( 'I\'m the Walrus!' ); // I'm the Walrus!

As you can see, we have to prepend the inner quote by the backslash \', because otherwise it would indicate the string end.

Of course, that refers only to the quotes that are same as the enclosing ones. So, as a more elegant solution, we could switch to double quotes or backticks instead:

	alert( `I'm the Walrus!` ); // I'm the Walrus!

Note that the backslash \ serves for the correct reading of the string by JavaScript, then disappears. The in-memory string has no \. You can clearly see that in alert from the examples above.

But what if we need to show an actual backslash \ within the string?

That‚Äôs possible, but we need to double it like \\:

	alert( `The backslash: \\` ); // The backslash: \

# String length

The length property has the string length:

	alert( `My\n`.length ); // 3

Note that \n is a single ‚Äúspecial‚Äù character, so the length is indeed 3.

## length is a property
People with a background in some other languages sometimes mistype by calling str.length() instead of just str.length. That doesn‚Äôt work.

Please note that str.length is a numeric property, not a function. There is no need to add parenthesis after it.

# Accessing characters

To get a character at position pos, use square brackets [pos] or call the method str.charAt(pos). The first character starts from the zero position:

	let str = `Hello`;

	// the first character
	alert( str[0] ); // H
	alert( str.charAt(0) ); // H

	// the last character
	alert( str[str.length - 1] ); // o

The square brackets are a modern way of getting a character, while charAt exists mostly for historical reasons.

`The only difference between them is that if no character is found, [] returns undefined, and charAt returns an empty string`:

	 let str = `Hello`;

	alert( str[1000] ); // undefined
	alert( str.charAt(1000) ); // '' (an empty string)


`We can also iterate over characters using for..of:`

	 for (let char of "Hello") {
	  alert(char); // H,e,l,l,o (char becomes "H", then "e", then "l" etc)
	}

# Strings are immutable

Strings can‚Äôt be changed in JavaScript. It is impossible to change a character.

Let‚Äôs try it to show that it doesn‚Äôt work:

	 let str = 'Hi';

	str[0] = 'h'; // error
	alert( str[0] ); // doesn't work

The usual workaround is to create a whole new string and assign it to str instead of the old one.

For instance:

	 let str = 'Hi';

	str = 'h' + str[1];  // replace the string

	alert( str ); // hi

In the following sections we‚Äôll see more examples of this.

# Changing the case

Methods toLowerCase() and toUpperCase() change the case:

	alert( 'Interface'.toUpperCase() ); // INTERFACE
	alert( 'Interface'.toLowerCase() ); // interface

Or, if we want a single character lowercased:

	alert( 'Interface'[0].toLowerCase() ); // 'i'

# Searching for a substring

There are multiple ways to look for a substring within a string.

## str.indexOf
The first method is str.indexOf(substr, pos).

It looks for the substr in str, starting from the given position pos, and returns the position where the match was found or -1 if nothing can be found.

For instance:

	 let str = 'Widget with id';

	alert( str.indexOf('Widget') ); // 0, because 'Widget' is found at the beginning
	alert( str.indexOf('widget') ); // -1, not found, the search is case-sensitive

	alert( str.indexOf("id") ); // 1, "id" is found at the position 1 (..idget with id)

The optional second parameter allows us to search starting from the given position.

For instance, the first occurrence of "id" is at position 1. To look for the next occurrence, let‚Äôs start the search from position 2:

	 let str = 'Widget with id';

	alert( str.indexOf('id', 2) ) // 12

If we‚Äôre interested in all occurrences, we can run indexOf in a loop. Every new call is made with the position after the previous match:

	 let str = 'As sly as a fox, as strong as an ox';

	let target = 'as'; // let's look for it

	let pos = 0;
	while (true) {
	  let foundPos = str.indexOf(target, pos);
	  if (foundPos == -1) break;

	  alert( `Found at ${foundPos}` );
	  pos = foundPos + 1; // continue the search from the next position
	}

The same algorithm can be layed out shorter:

	let str = "As sly as a fox, as strong as an ox";
	let target = "as";

	let pos = -1;
	while ((pos = str.indexOf(target, pos + 1)) != -1) {
	  alert( pos );
	}

## str.lastIndexOf(pos)
There is also a similar method str.lastIndexOf(pos) that searches from the end of a string to its beginning.

It would list the occurrences in the reverse order.

_There is a slight inconvenience with indexOf in the if test. We can‚Äôt put it in the if like this:_

	 let str = "Widget with id";

	if (str.indexOf("Widget")) {
	    alert("We found it"); // doesn't work!
	}

The alert in the example above doesn‚Äôt show because str.indexOf("Widget") returns 0 (meaning that it found the match at the starting position). Right, but if considers 0 to be false.

So, we should actually check for -1, like this:

	let str = "Widget with id";

	if (str.indexOf("Widget") != -1) {
	    alert("We found it"); // works now!
	}

# The bitwise NOT trick
One of the old tricks used here is the bitwise NOT ~ operator. It converts the number to a 32-bit integer (removes the decimal part if exists) and then reverses all bits in its binary representation.

For 32-bit integers the call `~n` means exactly the same as -(n+1) (due to IEEE-754 format).

For instance:

	alert( ~2 ); // -3, the same as -(2+1)
	alert( ~1 ); // -2, the same as -(1+1)
	alert( ~0 ); // -1, the same as -(0+1)
	alert( ~-1 ); // 0, the same as -(-1+1)

As we can see, `~n` is zero only if n == -1.

So, the test if ( `~str`.indexOf("...") ) is truthy that the result of indexOf is not -1. In other words, when there is a match.

People use it to shorten indexOf checks:

	 let str = "Widget";

	if (`~str`.indexOf("Widget")) {
	  alert( 'Found it!' ); // works
	}


It is usually not recommended to use language features in a non-obvious way, but this particular trick is widely used in old code, so we should understand it.

_Just remember: `if (~str.indexOf(...))` reads as ‚Äúif found‚Äù._

# [includes, startsWith, endsWith](https://javascript.info/string#includes-startswith-endswith)

The more modern method [str.includes(substr, pos)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes) returns true/false depending on whether str contains substr within.

It‚Äôs the right choice if we need to test for the match, but don‚Äôt need its position:

	alert( "Widget with id".includes("Widget") ); // true
	alert( "Hello".includes("Bye") ); // false

The optional second argument of str.includes is the position to start searching from:

	 alert( "Midget".includes("id") ); // true
	alert( "Midget".includes("id", 3) ); // false, from position 3 there is no "id"

The methods [str.startsWith](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith) and [str.endsWith](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith) do exactly what they say:

	 alert( "Widget".startsWith("Wid") ); // true, "Widget" starts with "Wid"
	alert( "Widget".endsWith("get") );   // true, "Widget" ends with "get"

# [Getting a substring](https://javascript.info/string#getting-a-substring)

There are 3 methods in JavaScript to get a substring: `substring, substr and slice.`

## str.slice(start [, end])

Returns the part of the string from start to (but not including) end.

For instance:

	let str = "stringify";
	alert( str.slice(0, 5) ); // 'strin', the substring from 0 to 5 (not including 5)
	alert( str.slice(0, 1) ); // 's', from 0 to 1, but not including 1, so only character at 0

If there is no second argument, then slice goes till the end of the string:

	let str = "stringify";
	alert( str.slice(2) ); // ringify, from the 2nd position till the end

Negative values for start/end are also possible. They mean the position is counted from the string end:

	let str = "stringify";

	// start at the 4th position from the right, end at the 1st from the right
	alert( str.slice(-4, -1) ); // gif

## 	str.substring(start [, end])

Returns the part of the string between start and end.

This is almost the same as slice, but it allows start to be greater than end.

For instance:

	let str = "stringify";

	// these are same for substring
	alert( str.substring(2, 6) ); // "ring"
	alert( str.substring(6, 2) ); // "ring"

	// ...but not for slice:
	alert( str.slice(2, 6) ); // "ring" (the same)
	alert( str.slice(6, 2) ); // "" (an empty string)

Negative arguments are (unlike slice) not supported, they are treated as 0.

## str.substr(start [, length])

Returns the part of the string from start, with the given length.

In contrast with the previous methods, this one allows us to specify the length instead of the ending position:

	let str = "stringify";
	alert( str.substr(2, 4) ); // ring, from the 2nd position get 4 characters

The first argument may be negative, to count from the end:

	let str = "stringify";
	alert( str.substr(-4, 2) ); // gi, from the 4th position get 2 characters

Let‚Äôs recap these methods to avoid any confusion:

## method	=> selects‚Ä¶	=> negatives

	slice(start, end)	=> from start to end (not including end)	=> allows negatives

	substring(start, end)	=> between start and end	=> negative values mean 0

	substr(start, length)	=> from start get length characters	=> allows negative start

## Which one to choose?

All of them can do the job. Formally, substr has a minor drawback: it is described not in the core JavaScript specification, but in Annex B, which covers browser-only features that exist mainly for historical reasons. So, non-browser environments may fail to support it. But in practice it works everywhere.

The author finds themself using slice almost all the time.

# [Comparing strings](https://javascript.info/string#comparing-strings)

As we know from the chapter Comparisons, strings are compared character-by-character in alphabetical order.

Although, there are some oddities.

A lowercase letter is always greater than the uppercase:

	alert( 'a' > 'Z' ); // true

Letters with diacritical marks are ‚Äúout of order‚Äù:

	alert( '√ñsterreich' > 'Zealand' ); // true

This may lead to strange results if we sort these country names. Usually people would expect Zealand to come after √ñsterreich in the list.

To understand what happens, let‚Äôs review the internal representation of strings in JavaScript.

All strings are encoded using UTF-16. That is: each character has a corresponding numeric code. There are special methods that allow to get the character for the code and back.

## str.codePointAt(pos)
Returns the code for the character at position pos:

	 // different case letters have different codes
	alert( "z".codePointAt(0) ); // 122
	alert( "Z".codePointAt(0) ); // 90

## String.fromCodePoint(code)
Creates a character by its numeric code

	alert( String.fromCodePoint(90) ); // Z

We can also add unicode characters by their codes using \u followed by the hex code:

	// 90 is 5a in hexadecimal system
	alert( '\u005a' ); // Z

Now let‚Äôs see the characters with codes 65..220 (the latin alphabet and a little bit extra) by making a string of them:

	 let str = '';

	for (let i = 65; i <= 220; i++) {
	  str += String.fromCodePoint(i);
	}
	alert( str );

See? Capital characters go first, then a few special ones, then lowercase characters.

Now it becomes obvious why a > Z.

The characters are compared by their numeric code. The greater code means that the character is greater. The code for a (97) is greater than the code for Z (90).

All lowercase letters go after uppercase letters because their codes are greater.
Some letters like √ñ stand apart from the main alphabet. Here, it‚Äôs code is greater than anything from a to z.

# [Correct comparisons](https://javascript.info/string#correct-comparisons)

The ‚Äúright‚Äù algorithm to do string comparisons is more complex than it may seem, because alphabets are different for different languages. The same-looking letter may be located differently in different alphabets.

So, the browser needs to know the language to compare.

Luckily, all modern browsers (IE10- requires the additional library [Intl.JS](https://github.com/andyearnshaw/Intl.js/)) support the internationalization standard [ECMA 402](http://www.ecma-international.org/ecma-402/1.0/ECMA-402.pdf).

It provides a special method to compare strings in different languages, following their rules.

The call str.localeCompare(str2):

	Returns 1 if str is greater than str2 according to the language rules.
	Returns -1 if str is less than str2.
	Returns 0 if they are equal.

For instance:

	alert( '√ñsterreich'.localeCompare('Zealand') ); // -1

This method actually has two additional arguments specified in the [documentation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare), which allows it to specify the language (by default taken from the environment) and setup additional rules like case sensitivity or should "a" and "aÃÅ" be treated as the same etc.

# [Internals, Unicode](https://javascript.info/string#internals-unicode)

## Advanced knowledge
The section goes deeper into string internals. This knowledge will be useful for you if you plan to deal with emoji, rare mathematical of hieroglyphs characters or other rare symbols.

You can skip the section if you don‚Äôt plan to support them.

# [Surrogate pairs](https://javascript.info/string#surrogate-pairs)

# [Diacritical marks and normalization](https://javascript.info/string#diacritical-marks-and-normalization)

# Summary

1. There are 3 types of quotes. Backticks allow a string to span multiple lines and embed expressions.
2. Strings in JavaScript are encoded using UTF-16.
3. We can use special characters like \n and insert letters by their unicode using \u....
4. To get a character, use: [].
5. To get a substring, use: slice or substring.
6. To lowercase/uppercase a string, use: toLowerCase/toUpperCase.
7. To look for a substring, use: indexOf, or includes/startsWith/endsWith for simple checks.
8. To compare strings according to the language, use: localeCompare, otherwise they are compared by character codes.


There are several other helpful methods in strings:

1. str.trim() ‚Äì removes (‚Äútrims‚Äù) spaces from the beginning and end of the string.
2. str.repeat(n) ‚Äì repeats the string n times.
3. ‚Ä¶and more. See the [manual](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String) for details.

Strings also have methods for doing search/replace with regular expressions. But that topic deserves a separate chapter, so we‚Äôll return to that later.


# Flashcards

https://quizlet.com/234426371/mjs-strings-flash-cards/